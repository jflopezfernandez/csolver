solver.c: In function 'reduceMatrix':
solver.c:13:6: warning: implicit declaration of function 'checkProgress' [-Wimplicit-function-declaration]
  p = checkProgress(m, reference);
      ^~~~~~~~~~~~~
solver.c:13:4: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
  p = checkProgress(m, reference);
    ^
solver.c:32:3: warning: implicit declaration of function 'reduceElement' [-Wimplicit-function-declaration]
   reduceElement(m, i, &(m->m[p->x][p->y]), p);
   ^~~~~~~~~~~~~
solver.c:33:5: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
   p = checkProgress(m, reference);
     ^
solver.c: At top level:
solver.c:46:6: warning: conflicting types for 'reduceElement'
 void reduceElement(struct _matrix *m, struct _matrix *i, struct _number *n, struct _progress *p) {
      ^~~~~~~~~~~~~
solver.c:32:3: note: previous implicit declaration of 'reduceElement' was here
   reduceElement(m, i, &(m->m[p->x][p->y]), p);
   ^~~~~~~~~~~~~
solver.c: In function 'reduceElement':
solver.c:47:12: warning: implicit declaration of function 'getNeededValue' [-Wimplicit-function-declaration]
  int val = getNeededValue(p->x,p->y);
            ^~~~~~~~~~~~~~
solver.c:53:15: warning: implicit declaration of function 'findComplementOne_' [-Wimplicit-function-declaration]
   operation = findComplementOne_(&(m->m[p->x][p->y]));
               ^~~~~~~~~~~~~~~~~~
solver.c:53:13: error: incompatible types when assigning to type 'struct _number' from type 'int'
   operation = findComplementOne_(&(m->m[p->x][p->y]));
             ^
solver.c:54:3: warning: implicit declaration of function 'doMultiply' [-Wimplicit-function-declaration]
   doMultiply(m,i,&operation, p);
   ^~~~~~~~~~
solver.c:60:15: warning: implicit declaration of function 'findComplementZero' [-Wimplicit-function-declaration]
   operation = findComplementZero(&(m->m[p->x][p->y]), &(m->m[(p->x)+1][p->y]));
               ^~~~~~~~~~~~~~~~~~
solver.c:60:13: error: incompatible types when assigning to type 'struct _number' from type 'int'
   operation = findComplementZero(&(m->m[p->x][p->y]), &(m->m[(p->x)+1][p->y]));
             ^
solver.c: At top level:
solver.c:81:16: error: conflicting types for 'findComplementOne_'
 struct _number findComplementOne_(struct _number *n) {
                ^~~~~~~~~~~~~~~~~~
solver.c:53:15: note: previous implicit declaration of 'findComplementOne_' was here
   operation = findComplementOne_(&(m->m[p->x][p->y]));
               ^~~~~~~~~~~~~~~~~~
solver.c: In function 'findComplementOne_':
solver.c:85:7: error: 'struct _number' has no member named 'n'
  if (n->n < 0) {
       ^~
solver.c:86:9: error: 'struct _number' has no member named 'n'
   result.n = -(n->d);
         ^
solver.c:86:17: error: 'struct _number' has no member named 'd'
   result.n = -(n->d);
                 ^~
solver.c:87:9: error: 'struct _number' has no member named 'd'
   result.d = -(n->n);
         ^
solver.c:87:17: error: 'struct _number' has no member named 'n'
   result.d = -(n->n);
                 ^~
solver.c:88:14: error: 'struct _number' has no member named 'n'
  } else if (n->n == 0) {
              ^~
solver.c:91:9: error: 'struct _number' has no member named 'n'
   result.n = n->d;
         ^
solver.c:91:15: error: 'struct _number' has no member named 'd'
   result.n = n->d;
               ^~
solver.c:92:9: error: 'struct _number' has no member named 'd'
   result.d = n->n;
         ^
solver.c:92:15: error: 'struct _number' has no member named 'n'
   result.d = n->n;
               ^~
solver.c: At top level:
solver.c:98:16: error: conflicting types for 'findComplementZero'
 struct _number findComplementZero(struct _number *m, struct _number *n) {
                ^~~~~~~~~~~~~~~~~~
solver.c:60:15: note: previous implicit declaration of 'findComplementZero' was here
   operation = findComplementZero(&(m->m[p->x][p->y]), &(m->m[(p->x)+1][p->y]));
               ^~~~~~~~~~~~~~~~~~
solver.c: In function 'findComplementZero':
solver.c:107:8: error: 'struct _number' has no member named 'n'
  if ((m->n > 0) && (n->n > 0)) {
        ^~
solver.c:107:22: error: 'struct _number' has no member named 'n'
  if ((m->n > 0) && (n->n > 0)) {
                      ^~
solver.c:110:14: error: 'struct _number' has no member named 'n'
  } else if (n->n < 0) {
              ^~
solver.c:112:8: error: 'struct _number' has no member named 'n'
   if (m->n < 0) {
        ^~
solver.c:119:14: error: 'struct _number' has no member named 'n'
  } else if (m->n == 0) {
              ^~
solver.c: At top level:
solver.c:131:6: warning: conflicting types for 'doMultiply'
 void doMultiply(struct _matrix *m1, struct _matrix *m2, struct _number *n, struct _progress *p) {
      ^~~~~~~~~~
solver.c:54:3: note: previous implicit declaration of 'doMultiply' was here
   doMultiply(m,i,&operation, p);
   ^~~~~~~~~~
solver.c:155:19: error: conflicting types for 'checkProgress'
 struct _progress* checkProgress(struct _matrix *m, struct _matrix *r) {
                   ^~~~~~~~~~~~~
solver.c:13:6: note: previous implicit declaration of 'checkProgress' was here
  p = checkProgress(m, reference);
      ^~~~~~~~~~~~~
solver.c: In function 'checkProgress':
solver.c:161:18: error: 'struct _number' has no member named 'n'
    if (m->m[j][i].n == r->m[j][i].n) {
                  ^
solver.c:161:34: error: 'struct _number' has no member named 'n'
    if (m->m[j][i].n == r->m[j][i].n) {
                                  ^
solver.c:162:19: error: 'struct _number' has no member named 'd'
     if (m->m[j][i].d == r->m[j][i].d) {
                   ^
solver.c:162:35: error: 'struct _number' has no member named 'd'
     if (m->m[j][i].d == r->m[j][i].d) {
                                   ^
make: *** [makefile:21: solver.o] Error 1
